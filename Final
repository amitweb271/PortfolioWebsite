
const createExcelFile = (data) => {
  const mainData = data.map(item => ({
    'Song Name': item.work,
    'Alternate Song Name': item.awork,
    'Language': item.language,
    'Sublanguage': item.sublanguage,
    'Movie Name': item.movie,
    'Subtitle': item.subtitle,
    'Type of Work': item.type_of_work,
    'Work Category': item.work_category,
    'Work Subcategory': item.work_subcategory,
    'Duration': item.duration,
    'CAE': item.cae,
    'Release Year': item.release_year,
    'Date of Release': item.date_of_release,
    'Inlay': item.inlay,
    'Website1': item.website1,
    'Website2': item.website2,
    'YouTube': item.youtube,
    'Label': item.label,
    'Producer': item.producer,
    'Director': item.director,
    'Principal': item.principal,
    'Supporting': item.supporting,
    'Production': item.production,
    'Channel': item.channel,
    'Joshua ID': item.songArtists.map(artist => artist.artist.joshua_id).join(', '), // Join Joshua IDs
    'Role': item.songArtists.map(artist => artist.role).join(', '), // Join Roles
    'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode).join(', '), // Join Tune Codes
    'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc).join(', '), // Join ISRCs
    'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc).join(', '), // Join ISWCs
    'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid).join(', '), // Join Society IDs
    'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid).join(', '), // Join Production IDs
    'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution).join(', '), // Join Last Date of Distribution
    'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator).join(', '), // Join Active Case Indicators
    'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus).join(', '), // Join Client Statuses
    'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus).join(', '), // Join General Statuses
    'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment).join(', '), // Join Purpose of Amendments
    'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon).join(', '), // Join Amendment Registered On
  }));

  const worksheet = XLSX.utils.json_to_sheet(mainData);

  const range = XLSX.utils.decode_range(worksheet['!ref']);
  for (let R = range.s.r; R <= range.e.r; ++R) {
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cellAddress = { c: C, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      if (worksheet[cellRef] && worksheet[cellRef].v === null) {
        worksheet[cellRef].v = "";
      } else if (worksheet[cellRef] && worksheet[cellRef].v && worksheet[cellRef].v.includes('Joshua ID')) {
        worksheet[cellRef].s = {
          fill: {
            fgColor: { rgb: "FFFF00" } // Yellow background for Joshua ID
          }
        };
      }
    }
  }

  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Combined Data');

  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, 'response.xlsx');
};








import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const mainData = data.map(item => ({
      'Song Name': item.work,
      'Alternate Song Name': item.awork,
      'Language': item.language,
      'Sublanguage': item.sublanguage,
      'Movie Name': item.movie,
      'Subtitle': item.subtitle,
      'Type of Work': item.type_of_work,
      'Work Category': item.work_category,
      'Work Subcategory': item.work_subcategory,
      'Duration': item.duration,
      'CAE': item.cae,
      'Release Year': item.release_year,
      'Date of Release': item.date_of_release,
      'Inlay': item.inlay,
      'Website1': item.website1,
      'Website2': item.website2,
      'YouTube': item.youtube,
      'Label': item.label,
      'Producer': item.producer,
      'Director': item.director,
      'Principal': item.principal,
      'Supporting': item.supporting,
      'Production': item.production,
      'Channel': item.channel,
    }));

    const songArtistsData = data.flatMap(item =>
      item.songArtists.map(artist => ({
        'Song Name': item.work,
        'Joshua ID': artist.artist.joshua_id,
        'Role': artist.role,
      }))
    );

    const tuneCodesData = data.flatMap(item =>
      item.tuneCodes.map(tuneCode => ({
        'Song Name': item.work,
        'Tune Code': tuneCode.tuneCode,
        'ISRC': tuneCode.isrc,
        'ISWC': tuneCode.iswc,
        'Society ID': tuneCode.societyid,
        'Production ID': tuneCode.productionid,
        'Last Date of Distribution': tuneCode.lastdateofdistribution,
        'Active Case Indicator': tuneCode.activecaseindicator,
        'Client Status': tuneCode.clientstatus,
        'General Status': tuneCode.generalstatus,
        'Purpose of Amendment': tuneCode.purposeofamendment,
        'Amendment Registered On': tuneCode.amendmentregisteredon,
      }))
    );

    const mainWorksheet = XLSX.utils.json_to_sheet(mainData);
    const songArtistsWorksheet = XLSX.utils.json_to_sheet(songArtistsData);
    const tuneCodesWorksheet = XLSX.utils.json_to_sheet(tuneCodesData);

    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, mainWorksheet, 'Main Data');
    XLSX.utils.book_append_sheet(workbook, songArtistsWorksheet, 'Song Artists');
    XLSX.utils.book_append_sheet(workbook, tuneCodesWorksheet, 'Tune Codes');

    const sheetNames = ['Main Data', 'Song Artists', 'Tune Codes'];
    sheetNames.forEach(sheetName => {
      const worksheet = workbook.Sheets[sheetName];
      const range = XLSX.utils.decode_range(worksheet['!ref']);
      for (let R = range.s.r; R <= range.e.r; ++R) {
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const cellAddress = { c: C, r: R };
          const cellRef = XLSX.utils.encode_cell(cellAddress);
          if (worksheet[cellRef] && !worksheet[cellRef].v) {
            worksheet[cellRef].s = {
              fill: {
                fgColor: { rgb: "FF0000" }
              }
            };
          }
        }
      }
    });

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist.joshua_id, sortable: true },
        { name: 'Role', selector: row => row.role, sortable: true },
      ]}
      data={data.songArtists}
      noHeader
    />
  );

  const TuneCodeComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Tune Code', selector: row => row.tuneCode, sortable: true },
        { name: 'ISRC', selector: row => row.isrc, sortable: true },
        { name: 'ISWC', selector: row => row.iswc, sortable: true },
        { name: 'Society ID', selector: row => row.societyid, sortable: true },
        { name: 'Production ID', selector: row => row.productionid, sortable: true },
        { name: 'Last Date of Distribution', selector: row => row.lastdateofdistribution, sortable: true },
        { name: 'Active Case Indicator', selector: row => row.activecaseindicator, sortable: true },
        { name: 'Client Status', selector: row => row.clientstatus, sortable: true },
        { name: 'General Status', selector: row => row.generalstatus, sortable: true },
        { name: 'Purpose of Amendment', selector: row => row.purposeofamendment, sortable: true },
        { name: 'Amendment Registered On', selector: row => row.amendmentregisteredon, sortable: true },
      ]}
      data={data.tuneCodes}
      noHeader
    />
  );

  const ExpandedComponent = ({ data }) => (
    <div>
      <SongArtistComponent data={data} />
      <TuneCodeComponent data={data} />
    </div>
  );

  return (
    <div className='card'>
      <div className='final-upload-header'>
        <h1>Final Upload</h1>
        <div className='final-upload-header-button'>
          <input type="file" onChange={handleFileChange} />
          <button className='button-70' onClick={handleUploadAndView}>UPLOAD & VIEW</button>
          <button className='button-70' onClick={handleSubmitExcelDatabase}>SUBMIT</button>
          <button className='button-70' onClick={handleDownloadExcel} disabled={!downloadData}>DOWNLOAD NOT UPLOADED SONG EXCEL</button>
        </div>
      </div>
      <br />
      {data.length > 0 && (
        <DataTable
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;







import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist.joshua_id, sortable: true },
        { name: 'Role', selector: row => row.role, sortable: true },
      ]}
      data={data.songArtists}
      noHeader
    />
  );

  const TuneCodeComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Tune Code', selector: row => row.tuneCode, sortable: true },
        { name: 'ISRC', selector: row => row.isrc, sortable: true },
        { name: 'ISWC', selector: row => row.iswc, sortable: true },
        { name: 'Society ID', selector: row => row.societyid, sortable: true },
        { name: 'Production ID', selector: row => row.productionid, sortable: true },
        { name: 'Last Date of Distribution', selector: row => row.lastdateofdistribution, sortable: true },
        { name: 'Active Case Indicator', selector: row => row.activecaseindicator, sortable: true },
        { name: 'Client Status', selector: row => row.clientstatus, sortable: true },
        { name: 'General Status', selector: row => row.generalstatus, sortable: true },
        { name: 'Purpose of Amendment', selector: row => row.purposeofamendment, sortable: true },
        { name: 'Amendment Registered On', selector: row => row.amendmentregisteredon, sortable: true },
      ]}
      data={data.tuneCodes}
      noHeader
    />
  );

  const ExpandedComponent = ({ data }) => (
    <div>
      <SongArtistComponent data={data} />
      <TuneCodeComponent data={data} />
    </div>
  );

  return (
    <div className='card'>
      <div className='final-upload-header'>
        <h1>Final Upload</h1>
        <div className='final-upload-header-button'>
          <input type="file" onChange={handleFileChange} />
          <button className='button-70' onClick={handleUploadAndView}>UPLOAD & VIEW</button>
          <button className='button-70' onClick={handleSubmitExcelDatabase}>SUBMIT</button>
          <button className='button-70' onClick={handleDownloadExcel} disabled={!downloadData}>DOWNLOAD NOT UPLOADED SONG EXCEL</button>
        </div>
      </div>
      <br />
      {data.length > 0 && (
        <DataTable
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
      cell: row => <div style={{ color: row.id ? 'black' : 'red' }}>{row.id}</div>
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
      cell: row => <div style={{ color: row.tuneCode ? 'black' : 'red' }}>{row.tuneCode}</div>
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
      cell: row => <div style={{ color: row.tuneNo ? 'black' : 'red' }}>{row.tuneNo}</div>
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
      cell: row => <div style={{ color: row.details.artist.name ? 'black' : 'red' }}>{row.details.artist.name}</div>
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
      cell: row => <div style={{ color: row.details.artist.genre ? 'black' : 'red' }}>{row.details.artist.genre}</div>
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
      cell: row => <div style={{ color: row.details.album.title ? 'black' : 'red' }}>{row.details.album.title}</div>
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
      cell: row => <div style={{ color: row.details.album.year ? 'black' : 'red' }}>{row.details.album.year}</div>
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
          cell: row => <div style={{ color: row.trackNo ? 'black' : 'red' }}>{row.trackNo}</div>
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
          cell: row => <div style={{ color: row.trackName ? 'black' : 'red' }}>{row.trackName}</div>
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  const exportToExcel = () => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');

    // Set the color for empty fields
    data.forEach((row, rowIndex) => {
      Object.keys(row).forEach((key) => {
        if (!row[key]) {
          const cellAddress = XLSX.utils.encode_cell({ c: Object.keys(row).indexOf(key), r: rowIndex + 1 });
          if (!worksheet[cellAddress]) {
            worksheet[cellAddress] = { s: { fill: { fgColor: { rgb: "FF0000" } } } };
          }
        }
      });
    });

    XLSX.writeFile(workbook, 'response.xlsx');
  };

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
        <button onClick={exportToExcel}>Export to Excel</button>
      </div>
      {data.length > 0 && (
        <DataTable
          title="Response Data"
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
      </div>
      {data.length > 0 && (
        <DataTable
          title="Response Data"
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;









import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleDownloadResponse = () => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'response.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
  ];

  // Component to render nested artist data
  const ArtistComponent = ({ data }) => (
    <DataTable
      title="Artist"
      columns={[
        {
          name: 'Album Title',
          selector: row => row.title,
          sortable: true,
        },
        {
          name: 'Album Year',
          selector: row => row.year,
          sortable: true,
        },
      ]}
      data={data.artist}
      noHeader
      pagination
    />
  );

  // Component to render nested tune code data
  const TrackComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.tunecode}
      noHeader
      pagination
    />
  );

  // Component to render nested data
  const ExpandedComponent = ({ data }) => (
    <div>
      <ArtistComponent data={data} />
      <TrackComponent data={data} />
    </div>
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleDownloadResponse} disabled={data.length === 0}>Download</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;









import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleDownloadResponse = () => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'response.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested sessions
  const SessionComponent = ({ data }) => (
    <DataTable
      title="Sessions"
      columns={[
        {
          name: 'Session ID',
          selector: row => row.sessionId,
          sortable: true,
        },
        {
          name: 'Session Name',
          selector: row => row.sessionName,
          sortable: true,
        },
      ]}
      data={data}
      noHeader
      pagination
    />
  );

  // Component to render nested tracks with expandable sessions
  const TrackComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data}
      noHeader
      pagination
      expandableRows
      expandableRowsComponent={({ data }) => <SessionComponent data={data.sessions} />}
    />
  );

  // Component to render details with expandable tracks
  const ExpandedComponent = ({ data }) => (
    <TrackComponent data={data.details.tracks} />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleDownloadResponse} disabled={data.length === 0}>Download</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input type="file" onChange={handleFileChange} />
        <button type="submit">Upload</button>
      </form>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;
