
import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);
  const [artists, setArtists] = useState([]);

  useEffect(() => {
    fetchAllArtists();
  }, []);

  const fetchAllArtists = async () => {
    try {
      const response = await axios.get(`${BASE_URL}artist/getAllArtists`, {
        headers: authHeader()
      });
      setArtists(response.data);
    } catch (error) {
      console.error('Error fetching artists:', error);
    }
  };

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const artistJoshuaIDs = artists.map(artist => artist.joshua_id);

    const mainData = data.map(item => ({
      'Song Name': item.work || '',
      'Alternate Song Name': item.awork || '',
      'Language': item.language || '',
      'Sublanguage': item.sublanguage || '',
      'Movie Name': item.movie || '',
      'Subtitle': item.subtitle || '',
      'Type of Work': item.type_of_work || '',
      'Work Category': item.work_category || '',
      'Work Subcategory': item.work_subcategory || '',
      'Duration': item.duration || '',
      'CAE': item.cae || '',
      'Release Year': item.release_year || '',
      'Date of Release': item.date_of_release || '',
      'Inlay': item.inlay || '',
      'Website1': item.website1 || '',
      'Website2': item.website2 || '',
      'YouTube': item.youtube || '',
      'Label': item.label || '',
      'Producer': item.producer || '',
      'Director': item.director || '',
      'Principal': item.principal || '',
      'Supporting': item.supporting || '',
      'Production': item.production || '',
      'Channel': item.channel || '',
      'Joshua ID': item.songArtists.map(artist => {
        const joshuaID = artist.artist ? artist.artist.joshua_id : '';
        return artistJoshuaIDs.includes(joshuaID) ? joshuaID : 'Joshua ID is not matching in database';
      }).filter(id => id).join(', '), // Join Joshua IDs, omit empty
      'Role': item.songArtists.map(artist => {
        const role = artist.role || '';
        return role === role.toUpperCase() ? role : 'Role is not capital letter';
      }).join(', '), // Check role capitalization
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode || '').filter(code => code).join(', '), // Join Tune Codes, omit empty
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc || '').filter(isrc => isrc).join(', '), // Join ISRCs, omit empty
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc || '').filter(iswc => iswc).join(', '), // Join ISWCs, omit empty
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid || '').filter(id => id).join(', '), // Join Society IDs, omit empty
      'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid || '').filter(id => id).join(', '), // Join Production IDs, omit empty
      'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution || '').filter(date => date).join(', '), // Join Last Date of Distribution, omit empty
      'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator || '').filter(indicator => indicator).join(', '), // Join Active Case Indicators, omit empty
      'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus || '').filter(status => status).join(', '), // Join Client Statuses, omit empty
      'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus || '').filter(status => status).join(', '), // Join General Statuses, omit empty
      'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment || '').filter(purpose => purpose).join(', '), // Join Purpose of Amendment, omit empty
      'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon || '').filter(date => date).join(', '), // Join Amendment Registered On, omit empty
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(mainData);

    // Style headers
    const headerRow = Object.keys(mainData[0]);
    headerRow.forEach((header, index) => {
      const cellAddress = { c: index, r: 0 }; // First row (0) and respective column (index)
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      worksheet[cellRef].s = {
        font: { sz: 14, bold: true, color: { rgb: "FFFFFF" } }, // Increase font size, bold and white color
        fill: { fgColor: { rgb: "4F81BD" } }, // Blue background
        alignment: { horizontal: "center", vertical: "center" } // Center alignment
      };
    });

    // Apply conditional formatting to cells
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r + 1; R <= range.e.r; ++R) { // start from range.s.r + 1 to skip header row
      const cellAddress = { c: 0, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      const cell = worksheet[cellRef];

      // Style for Song Name
      if (!cell || !cell.v) {
        worksheet[cellRef] = { t: 's', v: 'Empty', s: { fill: { fgColor: { rgb: "FF0000" } }, font: { sz: 12 } } }; // Red background for empty Song Name
      } else {
        worksheet[cellRef].s = { fill: { fgColor: { rgb: "FFFFFF" } }, font: { sz: 12 } }; // Normal style for non-empty cells
      }

      // Add other cell styles as required
      // For demonstration, setting the font size and color of other columns
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellRef = XLSX.utils.encode_cell({ c: C, r: R });
        const cell = worksheet[cellRef];

        if (cell) {
          cell.s = {
            font: { sz: 11, color: { rgb: "000000" } }, // Black font color and font size
            alignment: { vertical: "center", horizontal: "center" }, // Center alignment
          };

          // Apply different styles based on column (for demonstration)
          if (C === 1) { // Alternate Song Name
            cell.s.fill = { fgColor: { rgb: "F0F8FF" } }; // Light blue background
          }
          if (C === 2) { // Language
            cell.s.font = { sz: 14, color: { rgb: "000080" } }; // Larger font size, navy color
          }
          // Add other column-specific styles here
        }
      }
    }

    XLSX.utils.book






import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);
  const [artists, setArtists] = useState([]);

  useEffect(() => {
    fetchAllArtists();
  }, []);

  const fetchAllArtists = async () => {
    try {
      const response = await axios.get(`${BASE_URL}artist/getAllArtists`, {
        headers: authHeader()
      });
      setArtists(response.data);
    } catch (error) {
      console.error('Error fetching artists:', error);
    }
  };

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const artistJoshuaIDs = artists.map(artist => artist.joshua_id);

    const mainData = data.map(item => ({
      'Song Name': item.work || '',
      'Alternate Song Name': item.awork || '',
      'Language': item.language || '',
      'Sublanguage': item.sublanguage || '',
      'Movie Name': item.movie || '',
      'Subtitle': item.subtitle || '',
      'Type of Work': item.type_of_work || '',
      'Work Category': item.work_category || '',
      'Work Subcategory': item.work_subcategory || '',
      'Duration': item.duration || '',
      'CAE': item.cae || '',
      'Release Year': item.release_year || '',
      'Date of Release': item.date_of_release || '',
      'Inlay': item.inlay || '',
      'Website1': item.website1 || '',
      'Website2': item.website2 || '',
      'YouTube': item.youtube || '',
      'Label': item.label || '',
      'Producer': item.producer || '',
      'Director': item.director || '',
      'Principal': item.principal || '',
      'Supporting': item.supporting || '',
      'Production': item.production || '',
      'Channel': item.channel || '',
      'Joshua ID': item.songArtists.map(artist => {
        const joshuaID = artist.artist ? artist.artist.joshua_id : '';
        return artistJoshuaIDs.includes(joshuaID) ? joshuaID : 'Joshua ID is not matching in database';
      }).filter(id => id).join(', '), // Join Joshua IDs, omit empty
      'Role': item.songArtists.map(artist => {
        const role = artist.role || '';
        return role === role.toUpperCase() ? role : 'Role is not capital letter';
      }).join(', '), // Check role capitalization
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode || '').filter(code => code).join(', '), // Join Tune Codes, omit empty
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc || '').filter(isrc => isrc).join(', '), // Join ISRCs, omit empty
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc || '').filter(iswc => iswc).join(', '), // Join ISWCs, omit empty
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid || '').filter(id => id).join(', '), // Join Society IDs, omit empty
      'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid || '').filter(id => id).join(', '), // Join Production IDs, omit empty
      'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution || '').filter(date => date).join(', '), // Join Last Date of Distribution, omit empty
      'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator || '').filter(indicator => indicator).join(', '), // Join Active Case Indicators, omit empty
      'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus || '').filter(status => status).join(', '), // Join Client Statuses, omit empty
      'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus || '').filter(status => status).join(', '), // Join General Statuses, omit empty
      'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment || '').filter(purpose => purpose).join(', '), // Join Purpose of Amendment, omit empty
      'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon || '').filter(date => date).join(', '), // Join Amendment Registered On, omit empty
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(mainData);

    // Apply conditional formatting to cells
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r + 1; R <= range.e.r; ++R) { // start from range.s.r + 1 to skip header row
      const cellAddress = { c: 0, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      const cell = worksheet[cellRef];

      if (!cell || !cell.v) {
        worksheet[cellRef] = { t: 's', v: 'Empty', s: { fill: { fgColor: { rgb: "FF0000" } } } }; // Red background for empty Song Name
      }
    }

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Main Data');

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },



import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);
  const [artists, setArtists] = useState([]);

  useEffect(() => {
    fetchAllArtists();
  }, []);

  const fetchAllArtists = async () => {
    try {
      const response = await axios.get(`${BASE_URL}artist/getAllArtists`, {
        headers: authHeader()
      });
      setArtists(response.data);
    } catch (error) {
      console.error('Error fetching artists:', error);
    }
  };

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const artistJoshuaIDs = artists.map(artist => artist.joshua_id);

    const mainData = data.map(item => ({
      'Song Name': item.work || '',
      'Alternate Song Name': item.awork || '',
      'Language': item.language || '',
      'Sublanguage': item.sublanguage || '',
      'Movie Name': item.movie || '',
      'Subtitle': item.subtitle || '',
      'Type of Work': item.type_of_work || '',
      'Work Category': item.work_category || '',
      'Work Subcategory': item.work_subcategory || '',
      'Duration': item.duration || '',
      'CAE': item.cae || '',
      'Release Year': item.release_year || '',
      'Date of Release': item.date_of_release || '',
      'Inlay': item.inlay || '',
      'Website1': item.website1 || '',
      'Website2': item.website2 || '',
      'YouTube': item.youtube || '',
      'Label': item.label || '',
      'Producer': item.producer || '',
      'Director': item.director || '',
      'Principal': item.principal || '',
      'Supporting': item.supporting || '',
      'Production': item.production || '',
      'Channel': item.channel || '',
      'Joshua ID': item.songArtists.map(artist => {
        const joshuaID = artist.artist ? artist.artist.joshua_id : '';
        return artistJoshuaIDs.includes(joshuaID) ? joshuaID : 'Joshua ID is not matching in database';
      }).filter(id => id).join(', '), // Join Joshua IDs, omit empty
      'Role': item.songArtists.map(artist => {
        const role = artist.role || '';
        return role === role.toUpperCase() ? role : 'Role is not capital letter';
      }).join(', '), // Check role capitalization
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode || '').filter(code => code).join(', '), // Join Tune Codes, omit empty
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc || '').filter(isrc => isrc).join(', '), // Join ISRCs, omit empty
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc || '').filter(iswc => iswc).join(', '), // Join ISWCs, omit empty
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid || '').filter(id => id).join(', '), // Join Society IDs, omit empty
      'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid || '').filter(id => id).join(', '), // Join Production IDs, omit empty
      'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution || '').filter(date => date).join(', '), // Join Last Date of Distribution, omit empty
      'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator || '').filter(indicator => indicator).join(', '), // Join Active Case Indicators, omit empty
      'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus || '').filter(status => status).join(', '), // Join Client Statuses, omit empty
      'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus || '').filter(status => status).join(', '), // Join General Statuses, omit empty
      'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment || '').filter(purpose => purpose).join(', '), // Join Purpose of Amendment, omit empty
      'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon || '').filter(date => date).join(', '), // Join Amendment Registered On, omit empty
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(mainData);

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Main Data');

    // Apply styling to Joshua ID cells
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r; R <= range.e.r; ++R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = { c: C, r: R };
        const cellRef = XLSX.utils.encode_cell(cellAddress);
        const cell = worksheet[cellRef];

        if (cell && cell.v && cell.v.toString().includes('Joshua ID')) {
          cell.s = {
            fill: {
              fgColor: { rgb: "FFFF00" } // Yellow background
            }
          };
        }
      }
    }

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector





amit



import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const mainData = data.map(item => ({
      'Song Name': item.work || '',
      'Alternate Song Name': item.awork || '',
      'Language': item.language || '',
      'Sublanguage': item.sublanguage || '',
      'Movie Name': item.movie || '',
      'Subtitle': item.subtitle || '',
      'Type of Work': item.type_of_work || '',
      'Work Category': item.work_category || '',
      'Work Subcategory': item.work_subcategory || '',
      'Duration': item.duration || '',
      'CAE': item.cae || '',
      'Release Year': item.release_year || '',
      'Date of Release': item.date_of_release || '',
      'Inlay': item.inlay || '',
      'Website1': item.website1 || '',
      'Website2': item.website2 || '',
      'YouTube': item.youtube || '',
      'Label': item.label || '',
      'Producer': item.producer || '',
      'Director': item.director || '',
      'Principal': item.principal || '',
      'Supporting': item.supporting || '',
      'Production': item.production || '',
      'Channel': item.channel || '',
      'Joshua ID': item.songArtists.map(artist => (artist.artist ? artist.artist.joshua_id : '')).filter(id => id).join(', '), // Join Joshua IDs, omit empty
      'Role': item.songArtists.map(artist => artist.role || '').filter(role => role).join(', '), // Join Roles, omit empty
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode || '').filter(code => code).join(', '), // Join Tune Codes, omit empty
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc || '').filter(isrc => isrc).join(', '), // Join ISRCs, omit empty
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc || '').filter(iswc => iswc).join(', '), // Join ISWCs, omit empty
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid || '').filter(id => id).join(', '), // Join Society IDs, omit empty
      'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid || '').filter(id => id).join(', '), // Join Production IDs, omit empty
      'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution || '').filter(date => date).join(', '), // Join Last Date of Distribution, omit empty
      'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator || '').filter(indicator => indicator).join(', '), // Join Active Case Indicators, omit empty
      'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus || '').filter(status => status).join(', '), // Join Client Statuses, omit empty
      'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus || '').filter(status => status).join(', '), // Join General Statuses, omit empty
      'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment || '').filter(purpose => purpose).join(', '), // Join Purpose of Amendment, omit empty
      'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon || '').filter(date => date).join(', '), // Join Amendment Registered On, omit empty
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(mainData);

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Main Data');

    // Apply styling to Joshua ID cells
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r; R <= range.e.r; ++R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = { c: C, r: R };
        const cellRef = XLSX.utils.encode_cell(cellAddress);
        const cell = worksheet[cellRef];

        if (cell && cell.v && cell.v.toString().includes('Joshua ID')) {
          cell.s = {
            fill: {
              fgColor: { rgb: "FFFF00" } // Yellow background
            }
          };
        }
      }
    }

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist ? row.artist.joshua_id : '', sortable: true },
        { name: 'Role', selector: row => row.role || '', sortable:




import React, { useState } from 'react';
import { Form, Button, Container, Row, Col } from 'react-bootstrap';

const CompanyForm = () => {
  const [showBankDetails, setShowBankDetails] = useState(false);
  const [formData, setFormData] = useState({
    companyName: '',
    address: '',
    city: '',
    bankName: '',
    ifscCode: '',
    bankAddress: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Post the form data
    console.log('Form Data:', formData);

    // Example of posting data using fetch
    // Replace 'YOUR_API_ENDPOINT' with your actual API endpoint
    fetch('YOUR_API_ENDPOINT', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(formData)
    })
    .then(response => response.json())
    .then(data => {
      console.log('Success:', data);
    })
    .catch((error) => {
      console.error('Error:', error);
    });
  };

  return (
    <Container>
      <Form onSubmit={handleSubmit}>
        <Form.Group controlId="formCompanyName">
          <Form.Label>Company Name</Form.Label>
          <Form.Control 
            type="text" 
            placeholder="Enter company name" 
            name="companyName"
            value={formData.companyName}
            onChange={handleChange}
          />
        </Form.Group>

        <Form.Group controlId="formAddress">
          <Form.Label>Address</Form.Label>
          <Form.Control 
            type="text" 
            placeholder="Enter address" 
            name="address"
            value={formData.address}
            onChange={handleChange}
          />
        </Form.Group>

        <Form.Group controlId="formCity">
          <Form.Label>City</Form.Label>
          <Form.Control 
            type="text" 
            placeholder="Enter city" 
            name="city"
            value={formData.city}
            onChange={handleChange}
          />
        </Form.Group>

        <Button variant="primary" onClick={() => setShowBankDetails(!showBankDetails)}>
          {showBankDetails ? 'Hide Bank Details' : 'Add Bank Details'}
        </Button>

        {showBankDetails && (
          <>
            <Form.Group controlId="formBankName">
              <Form.Label>Bank Name</Form.Label>
              <Form.Control 
                type="text" 
                placeholder="Enter bank name" 
                name="bankName"
                value={formData.bankName}
                onChange={handleChange}
              />
            </Form.Group>

            <Form.Group controlId="formIFSCCode">
              <Form.Label>IFSC Code</Form.Label>
              <Form.Control 
                type="text" 
                placeholder="Enter IFSC code" 
                name="ifscCode"
                value={formData.ifscCode}
                onChange={handleChange}
              />
            </Form.Group>

            <Form.Group controlId="formBankAddress">
              <Form.Label>Bank Address</Form.Label>
              <Form.Control 
                type="text" 
                placeholder="Enter bank address" 
                name="bankAddress"
                value={formData.bankAddress}
                onChange={handleChange}
              />
            </Form.Group>
          </>
        )}

        <Button variant="primary" type="submit">
          Submit
        </Button>
      </Form>
    </Container>
  );
};

export default CompanyForm;



//////
import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const mainData = data.map(item => ({
      'Song Name': item.work || '',
      'Alternate Song Name': item.awork || '',
      'Language': item.language || '',
      'Sublanguage': item.sublanguage || '',
      'Movie Name': item.movie || '',
      'Subtitle': item.subtitle || '',
      'Type of Work': item.type_of_work || '',
      'Work Category': item.work_category || '',
      'Work Subcategory': item.work_subcategory || '',
      'Duration': item.duration || '',
      'CAE': item.cae || '',
      'Release Year': item.release_year || '',
      'Date of Release': item.date_of_release || '',
      'Inlay': item.inlay || '',
      'Website1': item.website1 || '',
      'Website2': item.website2 || '',
      'YouTube': item.youtube || '',
      'Label': item.label || '',
      'Producer': item.producer || '',
      'Director': item.director || '',
      'Principal': item.principal || '',
      'Supporting': item.supporting || '',
      'Production': item.production || '',
      'Channel': item.channel || '',
      'Joshua ID': item.songArtists.map(artist => artist.artist.joshua_id || '').filter(id => id).join(', '),
      'Role': item.songArtists.map(artist => artist.role || '').filter(role => role).join(', '),
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode || '').filter(code => code).join(', '),
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc || '').filter(isrc => isrc).join(', '),
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc || '').filter(iswc => iswc).join(', '),
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid || '').filter(id => id).join(', '),
      'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid || '').filter(id => id).join(', '),
      'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution || '').filter(date => date).join(', '),
      'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator || '').filter(indicator => indicator).join(', '),
      'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus || '').filter(status => status).join(', '),
      'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus || '').filter(status => status).join(', '),
      'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment || '').filter(purpose => purpose).join(', '),
      'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon || '').filter(date => date).join(', ')
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(mainData);

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Main Data');

    // Apply styling to Joshua ID cells
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r; R <= range.e.r; ++R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = { c: C, r: R };
        const cellRef = XLSX.utils.encode_cell(cellAddress);
        const cell = worksheet[cellRef];

        if (cell && cell.v && cell.v.toString().includes('Joshua ID')) {
          cell.s = {
            fill: {
              fgColor: { rgb: "FFFF00" } // Yellow background
            }
          };
        }
      }
    }

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist.joshua_id, sortable: true },
        { name: 'Role', selector: row => row.role, sortable: true },
      ]}
      data={data.songArtists}
      noHeader
    />
  );

  const TuneCodeComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Tune Code', selector: row => row.tuneCode, sortable: true },
        { name: 'ISRC', selector: row => row.isrc, sortable: true },
        { name: 'ISWC', selector: row => row.iswc, sortable: true },
        { name: 'Society ID', selector: row => row.societyid, sortable: true },
        { name: 'Production ID', selector: row => row







import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const mainData = data.map(item => ({
      'Song Name': item.work,
      'Alternate Song Name': item.awork,
      'Language': item.language,
      'Sublanguage': item.sublanguage,
      'Movie Name': item.movie,
      'Subtitle': item.subtitle,
      'Type of Work': item.type_of_work,
      'Work Category': item.work_category,
      'Work Subcategory': item.work_subcategory,
      'Duration': item.duration,
      'CAE': item.cae,
      'Release Year': item.release_year,
      'Date of Release': item.date_of_release,
      'Inlay': item.inlay,
      'Website1': item.website1,
      'Website2': item.website2,
      'YouTube': item.youtube,
      'Label': item.label,
      'Producer': item.producer,
      'Director': item.director,
      'Principal': item.principal,
      'Supporting': item.supporting,
      'Production': item.production,
      'Channel': item.channel,
      'Joshua ID': item.songArtists.map(artist => artist.artist.joshua_id).filter(id => id).join(', '), // Join Joshua IDs, omit empty
      'Role': item.songArtists.map(artist => artist.role).filter(role => role).join(', '), // Join Roles, omit empty
      'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode).filter(code => code).join(', '), // Join Tune Codes, omit empty
      'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc).filter(isrc => isrc).join(', '), // Join ISRCs, omit empty
      'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc).filter(iswc => iswc).join(', '), // Join ISWCs, omit empty
      'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid).filter(id => id).join



////////
import React, { useState } from 'react';
import axios from 'axios';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    // Combine main data, song artist data, and tune code data into a single dataset
    const combinedData = data.flatMap(item =>
      item.songArtists.flatMap(artist =>
        item.tuneCodes.map(tuneCode => ({
          'Song Name': item.work || "",
          'Alternate Song Name': item.awork || "",
          'Language': item.language || "",
          'Sublanguage': item.sublanguage || "",
          'Movie Name': item.movie || "",
          'Subtitle': item.subtitle || "",
          'Type of Work': item.type_of_work || "",
          'Work Category': item.work_category || "",
          'Work Subcategory': item.work_subcategory || "",
          'Duration': item.duration || "",
          'CAE': item.cae || "",
          'Release Year': item.release_year || "",
          'Date of Release': item.date_of_release || "",
          'Inlay': item.inlay || "",
          'Website1': item.website1 || "",
          'Website2': item.website2 || "",
          'YouTube': item.youtube || "",
          'Label': item.label || "",
          'Producer': item.producer || "",
          'Director': item.director || "",
          'Principal': item.principal || "",
          'Supporting': item.supporting || "",
          'Production': item.production || "",
          'Channel': item.channel || "",
          'Joshua ID': artist.artist.joshua_id || "",
          'Role': artist.role || "",
          'Tune Code': tuneCode.tuneCode || "",
          'ISRC': tuneCode.isrc || "",
          'ISWC': tuneCode.iswc || "",
          'Society ID': tuneCode.societyid || "",
          'Production ID': tuneCode.productionid || "",
          'Last Date of Distribution': tuneCode.lastdateofdistribution || "",
          'Active Case Indicator': tuneCode.activecaseindicator || "",
          'Client Status': tuneCode.clientstatus || "",
          'General Status': tuneCode.generalstatus || "",
          'Purpose of Amendment': tuneCode.purposeofamendment || "",
          'Amendment Registered On': tuneCode.amendmentregisteredon || ""
        }))
      )
    );

    const worksheet = XLSX.utils.json_to_sheet(combinedData);

    const range = XLSX.utils.decode_range(worksheet['!ref']);
    for (let R = range.s.r; R <= range.e.r; ++R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = { c: C, r: R };
        const cellRef = XLSX.utils.encode_cell(cellAddress);
        const cell = worksheet[cellRef];
        if (cell && cell.v !== null && cell.v !== "") {
          if (Object.keys(combinedData[0])[C] === 'Joshua ID' && cell.v) {
            // Apply yellow background for Joshua ID cells
            cell.s = {
              fill: {
                fgColor: { rgb: "FFFF00" }
              }
            };
          } else {
            // Apply other styling rules here as needed
            cell.s = {
              fill: {
                fgColor: { rgb: "FFFFFF" } // Default white background for other cells
              }
            };
          }
        } else {
          worksheet[cellRef] = { v: "" };
          worksheet[cellRef].s = {
            fill: {
              fgColor: { rgb: "FF0000" } // Red background for empty cells
            }
          };
        }
      }
    }

    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'All Data');

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, 'response.xlsx');
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  return (
    <div className='card'>
      <div className='final-upload-header'>
        <h1>Final Upload</h1>
        <div className='final-upload-header-button'>
          <input type="file" onChange={handleFileChange} />
          <button className='button-70' onClick={handleUploadAndView}>UPLOAD & VIEW</button>
          <button className='button-70' onClick={handleSubmitExcelDatabase}>SUBMIT</button>
          <button className='button-70' onClick={handleDownloadExcel} disabled={!downloadData}>DOWNLOAD NOT UPLOADED SONG EXCEL</button>
        </div>
      </div>
      <br />
      {data.length > 0 && (
        <DataTable
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;






const createExcelFile = (data) => {
  // Combine main data, song artist data, and tune code data into a single dataset
  const combinedData = data.map(item => {
    return item.songArtists.map(artist => {
      return item.tuneCodes.map(tuneCode => ({
        'Song Name': item.work || "",
        'Alternate Song Name': item.awork || "",
        'Language': item.language || "",
        'Sublanguage': item.sublanguage || "",
        'Movie Name': item.movie || "",
        'Subtitle': item.subtitle || "",
        'Type of Work': item.type_of_work || "",
        'Work Category': item.work_category || "",
        'Work Subcategory': item.work_subcategory || "",
        'Duration': item.duration || "",
        'CAE': item.cae || "",
        'Release Year': item.release_year || "",
        'Date of Release': item.date_of_release || "",
        'Inlay': item.inlay || "",
        'Website1': item.website1 || "",
        'Website2': item.website2 || "",
        'YouTube': item.youtube || "",
        'Label': item.label || "",
        'Producer': item.producer || "",
        'Director': item.director || "",
        'Principal': item.principal || "",
        'Supporting': item.supporting || "",
        'Production': item.production || "",
        'Channel': item.channel || "",
        'Joshua ID': artist.artist.joshua_id || "",
        'Role': artist.role || "",
        'Tune Code': tuneCode.tuneCode || "",
        'ISRC': tuneCode.isrc || "",
        'ISWC': tuneCode.iswc || "",
        'Society ID': tuneCode.societyid || "",
        'Production ID': tuneCode.productionid || "",
        'Last Date of Distribution': tuneCode.lastdateofdistribution || "",
        'Active Case Indicator': tuneCode.activecaseindicator || "",
        'Client Status': tuneCode.clientstatus || "",
        'General Status': tuneCode.generalstatus || "",
        'Purpose of Amendment': tuneCode.purposeofamendment || "",
        'Amendment Registered On': tuneCode.amendmentregisteredon || ""
      }));
    }).flat();
  }).flat();

  const worksheet = XLSX.utils.json_to_sheet(combinedData);

  const range = XLSX.utils.decode_range(worksheet['!ref']);
  for (let R = range.s.r; R <= range.e.r; ++R) {
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cellAddress = { c: C, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      const cell = worksheet[cellRef];
      if (!cell || cell.v === null) {
        worksheet[cellRef] = { v: "" };
        worksheet[cellRef].s = {
          fill: {
            fgColor: { rgb: "FF0000" } // Red background for empty cells
          }
        };
      } else if (combinedData[0] && Object.keys(combinedData[0])[C] === 'Joshua ID') {
        worksheet[cellRef].s = {
          fill: {
            fgColor: { rgb: "FFFF00" } // Yellow background for Joshua ID cells
          }
        };
      }
    }
  }

  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, 'All Data');

  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, 'response.xlsx');
};

// The rest of your code remains unchanged

const createExcelFile = (data) => {
  const mainData = data.map(item => ({
    'Song Name': item.work,
    'Alternate Song Name': item.awork,
    'Language': item.language,
    'Sublanguage': item.sublanguage,
    'Movie Name': item.movie,
    'Subtitle': item.subtitle,
    'Type of Work': item.type_of_work,
    'Work Category': item.work_category,
    'Work Subcategory': item.work_subcategory,
    'Duration': item.duration,
    'CAE': item.cae,
    'Release Year': item.release_year,
    'Date of Release': item.date_of_release,
    'Inlay': item.inlay,
    'Website1': item.website1,
    'Website2': item.website2,
    'YouTube': item.youtube,
    'Label': item.label,
    'Producer': item.producer,
    'Director': item.director,
    'Principal': item.principal,
    'Supporting': item.supporting,
    'Production': item.production,
    'Channel': item.channel,
    'Joshua ID': item.songArtists.map(artist => artist.artist.joshua_id).join(', '), // Join Joshua IDs
    'Role': item.songArtists.map(artist => artist.role).join(', '), // Join Roles
    'Tune Code': item.tuneCodes.map(tuneCode => tuneCode.tuneCode).join(', '), // Join Tune Codes
    'ISRC': item.tuneCodes.map(tuneCode => tuneCode.isrc).join(', '), // Join ISRCs
    'ISWC': item.tuneCodes.map(tuneCode => tuneCode.iswc).join(', '), // Join ISWCs
    'Society ID': item.tuneCodes.map(tuneCode => tuneCode.societyid).join(', '), // Join Society IDs
    'Production ID': item.tuneCodes.map(tuneCode => tuneCode.productionid).join(', '), // Join Production IDs
    'Last Date of Distribution': item.tuneCodes.map(tuneCode => tuneCode.lastdateofdistribution).join(', '), // Join Last Date of Distribution
    'Active Case Indicator': item.tuneCodes.map(tuneCode => tuneCode.activecaseindicator).join(', '), // Join Active Case Indicators
    'Client Status': item.tuneCodes.map(tuneCode => tuneCode.clientstatus).join(', '), // Join Client Statuses
    'General Status': item.tuneCodes.map(tuneCode => tuneCode.generalstatus).join(', '), // Join General Statuses
    'Purpose of Amendment': item.tuneCodes.map(tuneCode => tuneCode.purposeofamendment).join(', '), // Join Purpose of Amendments
    'Amendment Registered On': item.tuneCodes.map(tuneCode => tuneCode.amendmentregisteredon).join(', '), // Join Amendment Registered On
  }));

  const worksheet = XLSX.utils.json_to_sheet(mainData);

  const range = XLSX.utils.decode_range(worksheet['!ref']);
  for (let R = range.s.r; R <= range.e.r; ++R) {
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cellAddress = { c: C, r: R };
      const cellRef = XLSX.utils.encode_cell(cellAddress);
      if (worksheet[cellRef] && worksheet[cellRef].v === null) {
        worksheet[cellRef].v = "";
      } else if (worksheet[cellRef] && worksheet[cellRef].v && worksheet[cellRef].v.includes('Joshua ID')) {
        worksheet[cellRef].s = {
          fill: {
            fgColor: { rgb: "FFFF00" } // Yellow background for Joshua ID
          }
        };
      }
    }
  }

  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Combined Data');

  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, 'response.xlsx');
};








import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const mainData = data.map(item => ({
      'Song Name': item.work,
      'Alternate Song Name': item.awork,
      'Language': item.language,
      'Sublanguage': item.sublanguage,
      'Movie Name': item.movie,
      'Subtitle': item.subtitle,
      'Type of Work': item.type_of_work,
      'Work Category': item.work_category,
      'Work Subcategory': item.work_subcategory,
      'Duration': item.duration,
      'CAE': item.cae,
      'Release Year': item.release_year,
      'Date of Release': item.date_of_release,
      'Inlay': item.inlay,
      'Website1': item.website1,
      'Website2': item.website2,
      'YouTube': item.youtube,
      'Label': item.label,
      'Producer': item.producer,
      'Director': item.director,
      'Principal': item.principal,
      'Supporting': item.supporting,
      'Production': item.production,
      'Channel': item.channel,
    }));

    const songArtistsData = data.flatMap(item =>
      item.songArtists.map(artist => ({
        'Song Name': item.work,
        'Joshua ID': artist.artist.joshua_id,
        'Role': artist.role,
      }))
    );

    const tuneCodesData = data.flatMap(item =>
      item.tuneCodes.map(tuneCode => ({
        'Song Name': item.work,
        'Tune Code': tuneCode.tuneCode,
        'ISRC': tuneCode.isrc,
        'ISWC': tuneCode.iswc,
        'Society ID': tuneCode.societyid,
        'Production ID': tuneCode.productionid,
        'Last Date of Distribution': tuneCode.lastdateofdistribution,
        'Active Case Indicator': tuneCode.activecaseindicator,
        'Client Status': tuneCode.clientstatus,
        'General Status': tuneCode.generalstatus,
        'Purpose of Amendment': tuneCode.purposeofamendment,
        'Amendment Registered On': tuneCode.amendmentregisteredon,
      }))
    );

    const mainWorksheet = XLSX.utils.json_to_sheet(mainData);
    const songArtistsWorksheet = XLSX.utils.json_to_sheet(songArtistsData);
    const tuneCodesWorksheet = XLSX.utils.json_to_sheet(tuneCodesData);

    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, mainWorksheet, 'Main Data');
    XLSX.utils.book_append_sheet(workbook, songArtistsWorksheet, 'Song Artists');
    XLSX.utils.book_append_sheet(workbook, tuneCodesWorksheet, 'Tune Codes');

    const sheetNames = ['Main Data', 'Song Artists', 'Tune Codes'];
    sheetNames.forEach(sheetName => {
      const worksheet = workbook.Sheets[sheetName];
      const range = XLSX.utils.decode_range(worksheet['!ref']);
      for (let R = range.s.r; R <= range.e.r; ++R) {
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const cellAddress = { c: C, r: R };
          const cellRef = XLSX.utils.encode_cell(cellAddress);
          if (worksheet[cellRef] && !worksheet[cellRef].v) {
            worksheet[cellRef].s = {
              fill: {
                fgColor: { rgb: "FF0000" }
              }
            };
          }
        }
      }
    });

    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist.joshua_id, sortable: true },
        { name: 'Role', selector: row => row.role, sortable: true },
      ]}
      data={data.songArtists}
      noHeader
    />
  );

  const TuneCodeComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Tune Code', selector: row => row.tuneCode, sortable: true },
        { name: 'ISRC', selector: row => row.isrc, sortable: true },
        { name: 'ISWC', selector: row => row.iswc, sortable: true },
        { name: 'Society ID', selector: row => row.societyid, sortable: true },
        { name: 'Production ID', selector: row => row.productionid, sortable: true },
        { name: 'Last Date of Distribution', selector: row => row.lastdateofdistribution, sortable: true },
        { name: 'Active Case Indicator', selector: row => row.activecaseindicator, sortable: true },
        { name: 'Client Status', selector: row => row.clientstatus, sortable: true },
        { name: 'General Status', selector: row => row.generalstatus, sortable: true },
        { name: 'Purpose of Amendment', selector: row => row.purposeofamendment, sortable: true },
        { name: 'Amendment Registered On', selector: row => row.amendmentregisteredon, sortable: true },
      ]}
      data={data.tuneCodes}
      noHeader
    />
  );

  const ExpandedComponent = ({ data }) => (
    <div>
      <SongArtistComponent data={data} />
      <TuneCodeComponent data={data} />
    </div>
  );

  return (
    <div className='card'>
      <div className='final-upload-header'>
        <h1>Final Upload</h1>
        <div className='final-upload-header-button'>
          <input type="file" onChange={handleFileChange} />
          <button className='button-70' onClick={handleUploadAndView}>UPLOAD & VIEW</button>
          <button className='button-70' onClick={handleSubmitExcelDatabase}>SUBMIT</button>
          <button className='button-70' onClick={handleDownloadExcel} disabled={!downloadData}>DOWNLOAD NOT UPLOADED SONG EXCEL</button>
        </div>
      </div>
      <br />
      {data.length > 0 && (
        <DataTable
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;







import '@fortawesome/fontawesome-free/css/all.min.css';
import 'bootstrap-css-only/css/bootstrap.min.css';
import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { BASE_URL } from '../../services/Api';
import authHeader from '../../services/auth-header';
import Swal from 'sweetalert2';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadData, setDownloadData] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleUploadAndView = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/view`, formData, {
        headers: authHeader()
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data);
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSubmitExcelDatabase = async () => {
    if (!selectedFile) {
      Swal.fire("Please select an Excel file first!");
      return;
    }

    const formData = new FormData();
    formData.append('multi', selectedFile);

    try {
      const response = await axios.post(`${BASE_URL}song/finalUploadExcel`, formData, {
        headers: authHeader()
      });
      setDownloadData(response.data);
      createExcelFile(response.data);
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const createExcelFile = (data) => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    setDownloadData(url);
  };

  const handleDownloadExcel = () => {
    if (downloadData) {
      saveAs(downloadData, 'response.xlsx');
      URL.revokeObjectURL(downloadData);
      setDownloadData(null);
    }
  };

  const columns = [
    { name: 'Song Name', selector: 'work', sortable: true },
    { name: 'Alternate Song Name', selector: 'awork', sortable: true },
    { name: 'Language', selector: 'language', sortable: true },
    { name: 'Sublanguage', selector: 'sublanguage', sortable: true },
    { name: 'Movie Name', selector: 'movie', sortable: true },
    { name: 'Subtitle', selector: 'subtitle', sortable: true },
    { name: 'Type of Work', selector: 'type_of_work', sortable: true },
    { name: 'Work Category', selector: 'work_category', sortable: true },
    { name: 'Work Subcategory', selector: 'work_subcategory', sortable: true },
    { name: 'Duration', selector: 'duration', sortable: true },
    { name: 'CAE', selector: 'cae', sortable: true },
    { name: 'Release Year', selector: 'release_year', sortable: true },
    { name: 'Date of Release', selector: 'date_of_release', sortable: true },
    { name: 'Inlay', selector: 'inlay', sortable: true },
    { name: 'Website1', selector: 'website1', sortable: true },
    { name: 'Website2', selector: 'website2', sortable: true },
    { name: 'YouTube', selector: 'youtube', sortable: true },
    { name: 'Label', selector: 'label', sortable: true },
    { name: 'Producer', selector: 'producer', sortable: true },
    { name: 'Director', selector: 'director', sortable: true },
    { name: 'Principal', selector: 'principal', sortable: true },
    { name: 'Supporting', selector: 'supporting', sortable: true },
    { name: 'Production', selector: 'production', sortable: true },
    { name: 'Channel', selector: 'channel', sortable: true },
  ];

  const SongArtistComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Joshua ID', selector: row => row.artist.joshua_id, sortable: true },
        { name: 'Role', selector: row => row.role, sortable: true },
      ]}
      data={data.songArtists}
      noHeader
    />
  );

  const TuneCodeComponent = ({ data }) => (
    <DataTable
      columns={[
        { name: 'Tune Code', selector: row => row.tuneCode, sortable: true },
        { name: 'ISRC', selector: row => row.isrc, sortable: true },
        { name: 'ISWC', selector: row => row.iswc, sortable: true },
        { name: 'Society ID', selector: row => row.societyid, sortable: true },
        { name: 'Production ID', selector: row => row.productionid, sortable: true },
        { name: 'Last Date of Distribution', selector: row => row.lastdateofdistribution, sortable: true },
        { name: 'Active Case Indicator', selector: row => row.activecaseindicator, sortable: true },
        { name: 'Client Status', selector: row => row.clientstatus, sortable: true },
        { name: 'General Status', selector: row => row.generalstatus, sortable: true },
        { name: 'Purpose of Amendment', selector: row => row.purposeofamendment, sortable: true },
        { name: 'Amendment Registered On', selector: row => row.amendmentregisteredon, sortable: true },
      ]}
      data={data.tuneCodes}
      noHeader
    />
  );

  const ExpandedComponent = ({ data }) => (
    <div>
      <SongArtistComponent data={data} />
      <TuneCodeComponent data={data} />
    </div>
  );

  return (
    <div className='card'>
      <div className='final-upload-header'>
        <h1>Final Upload</h1>
        <div className='final-upload-header-button'>
          <input type="file" onChange={handleFileChange} />
          <button className='button-70' onClick={handleUploadAndView}>UPLOAD & VIEW</button>
          <button className='button-70' onClick={handleSubmitExcelDatabase}>SUBMIT</button>
          <button className='button-70' onClick={handleDownloadExcel} disabled={!downloadData}>DOWNLOAD NOT UPLOADED SONG EXCEL</button>
        </div>
      </div>
      <br />
      {data.length > 0 && (
        <DataTable
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
      cell: row => <div style={{ color: row.id ? 'black' : 'red' }}>{row.id}</div>
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
      cell: row => <div style={{ color: row.tuneCode ? 'black' : 'red' }}>{row.tuneCode}</div>
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
      cell: row => <div style={{ color: row.tuneNo ? 'black' : 'red' }}>{row.tuneNo}</div>
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
      cell: row => <div style={{ color: row.details.artist.name ? 'black' : 'red' }}>{row.details.artist.name}</div>
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
      cell: row => <div style={{ color: row.details.artist.genre ? 'black' : 'red' }}>{row.details.artist.genre}</div>
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
      cell: row => <div style={{ color: row.details.album.title ? 'black' : 'red' }}>{row.details.album.title}</div>
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
      cell: row => <div style={{ color: row.details.album.year ? 'black' : 'red' }}>{row.details.album.year}</div>
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
          cell: row => <div style={{ color: row.trackNo ? 'black' : 'red' }}>{row.trackNo}</div>
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
          cell: row => <div style={{ color: row.trackName ? 'black' : 'red' }}>{row.trackName}</div>
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  const exportToExcel = () => {
    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');

    // Set the color for empty fields
    data.forEach((row, rowIndex) => {
      Object.keys(row).forEach((key) => {
        if (!row[key]) {
          const cellAddress = XLSX.utils.encode_cell({ c: Object.keys(row).indexOf(key), r: rowIndex + 1 });
          if (!worksheet[cellAddress]) {
            worksheet[cellAddress] = { s: { fill: { fgColor: { rgb: "FF0000" } } } };
          }
        }
      });
    });

    XLSX.writeFile(workbook, 'response.xlsx');
  };

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
        <button onClick={exportToExcel}>Export to Excel</button>
      </div>
      {data.length > 0 && (
        <DataTable
          title="Response Data"
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
      </div>
      {data.length > 0 && (
        <DataTable
          title="Response Data"
          columns={columns}
          data={data}
          pagination
          expandableRows
          expandableRowsComponent={ExpandedComponent}
        />
      )}
    </div>
  );
};

export default FileUpload;









import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleDownloadResponse = () => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'response.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
  ];

  // Component to render nested artist data
  const ArtistComponent = ({ data }) => (
    <DataTable
      title="Artist"
      columns={[
        {
          name: 'Album Title',
          selector: row => row.title,
          sortable: true,
        },
        {
          name: 'Album Year',
          selector: row => row.year,
          sortable: true,
        },
      ]}
      data={data.artist}
      noHeader
      pagination
    />
  );

  // Component to render nested tune code data
  const TrackComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.tunecode}
      noHeader
      pagination
    />
  );

  // Component to render nested data
  const ExpandedComponent = ({ data }) => (
    <div>
      <ArtistComponent data={data} />
      <TrackComponent data={data} />
    </div>
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleDownloadResponse} disabled={data.length === 0}>Download</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;









import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleDownloadResponse = () => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'response.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested sessions
  const SessionComponent = ({ data }) => (
    <DataTable
      title="Sessions"
      columns={[
        {
          name: 'Session ID',
          selector: row => row.sessionId,
          sortable: true,
        },
        {
          name: 'Session Name',
          selector: row => row.sessionName,
          sortable: true,
        },
      ]}
      data={data}
      noHeader
      pagination
    />
  );

  // Component to render nested tracks with expandable sessions
  const TrackComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data}
      noHeader
      pagination
      expandableRows
      expandableRowsComponent={({ data }) => <SessionComponent data={data.sessions} />}
    />
  );

  // Component to render details with expandable tracks
  const ExpandedComponent = ({ data }) => (
    <TrackComponent data={data.details.tracks} />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleDownloadResponse} disabled={data.length === 0}>Download</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';
import { saveAs } from 'file-saver';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);
  const [downloadUrl, setDownloadUrl] = useState(null);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSendRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  const handleSendExcelRequest = async () => {
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload-excel', formData, {
        responseType: 'blob',
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      setDownloadUrl(URL.createObjectURL(blob));
    } catch (error) {
      console.error('Error uploading Excel file:', error);
    }
  };

  const handleDownloadExcel = () => {
    if (downloadUrl) {
      saveAs(downloadUrl, 'response.xlsx');
      URL.revokeObjectURL(downloadUrl);
      setDownloadUrl(null);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <div>
        <input type="file" onChange={handleFileChange} />
        <button onClick={handleSendRequest}>Send</button>
        <button onClick={handleSendExcelRequest}>Send Excel</button>
        <button onClick={handleDownloadExcel} disabled={!downloadUrl}>Download Excel</button>
      </div>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;





import React, { useState } from 'react';
import axios from 'axios';
import DataTable from 'react-data-table-component';

const FileUpload = () => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [data, setData] = useState([]);

  const handleFileChange = (event) => {
    setSelectedFile(event.target.files[0]);
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await axios.post('/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      console.log('File uploaded successfully:', response.data);
      setData(response.data); // Set the response data to the state
    } catch (error) {
      console.error('Error uploading file:', error);
    }
  };

  // Define columns for the main data table
  const columns = [
    {
      name: 'ID',
      selector: row => row.id,
      sortable: true,
    },
    {
      name: 'Tune Code',
      selector: row => row.tuneCode,
      sortable: true,
    },
    {
      name: 'Tune Number',
      selector: row => row.tuneNo,
      sortable: true,
    },
    {
      name: 'Artist Name',
      selector: row => row.details.artist.name,
      sortable: true,
    },
    {
      name: 'Artist Genre',
      selector: row => row.details.artist.genre,
      sortable: true,
    },
    {
      name: 'Album Title',
      selector: row => row.details.album.title,
      sortable: true,
    },
    {
      name: 'Album Year',
      selector: row => row.details.album.year,
      sortable: true,
    },
  ];

  // Component to render nested tracks
  const ExpandedComponent = ({ data }) => (
    <DataTable
      title="Tracks"
      columns={[
        {
          name: 'Track Number',
          selector: row => row.trackNo,
          sortable: true,
        },
        {
          name: 'Track Name',
          selector: row => row.trackName,
          sortable: true,
        },
      ]}
      data={data.details.tracks}
      noHeader
      pagination
    />
  );

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input type="file" onChange={handleFileChange} />
        <button type="submit">Upload</button>
      </form>
      <DataTable
        title="Response Data"
        columns={columns}
        data={data}
        pagination
        expandableRows
        expandableRowsComponent={ExpandedComponent}
      />
    </div>
  );
};

export default FileUpload;
